{"ast":null,"code":"import _classCallCheck from \"/Users/dub_ceo/Desktop/spacesvr-starter/node_modules/next/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/dub_ceo/Desktop/spacesvr-starter/node_modules/next/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _defineProperty from \"/Users/dub_ceo/Desktop/spacesvr-starter/node_modules/next/node_modules/@babel/runtime/helpers/esm/defineProperty\";\n// @ts-ignore\nimport * as culori from \"culori\";\n\n/**\n * an idea is the fundamental atom of the ideal reality.\n * everything is an idea, whether the idea is accurately visualized or not.\n */\nexport var Idea = /*#__PURE__*/function () {\n  // definition\n  // aliases\n  // size\n  // thought\n  // mediation\n  // [0, 1)\n  // [0, 1]\n  // [0, 1]\n  function Idea() {\n    _classCallCheck(this, Idea);\n\n    _defineProperty(this, \"id\", void 0);\n\n    _defineProperty(this, \"props\", void 0);\n\n    _defineProperty(this, \"name\", void 0);\n\n    _defineProperty(this, \"schema\", void 0);\n\n    _defineProperty(this, \"npm_dependencies\", void 0);\n\n    _defineProperty(this, \"purpose\", void 0);\n\n    _defineProperty(this, \"predecessor\", void 0);\n\n    _defineProperty(this, \"mediation\", void 0);\n\n    _defineProperty(this, \"specificity\", void 0);\n\n    _defineProperty(this, \"utility\", void 0);\n\n    this.setFromCreation();\n    return this;\n  }\n\n  _createClass(Idea, [{\n    key: \"setFromCreation\",\n    value: function setFromCreation() {\n      var m = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var s = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var u = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.5;\n      this.mediation = m;\n      this.specificity = s;\n      this.utility = u;\n      return this;\n    }\n  }, {\n    key: \"updateFromText\",\n    value: function updateFromText(text) {\n      var len = text.length;\n      this.mediation = hashStringToRange(text);\n      this.specificity = (1 - (len == 0 ? 1 : 1 / len)) * 0.5;\n      return this;\n    }\n  }, {\n    key: \"updateUtility\",\n    value: function updateUtility(utility) {\n      this.utility = utility;\n      return this;\n    }\n  }, {\n    key: \"getHex\",\n    value: function getHex() {\n      var fixedColor = culori.rgb({\n        mode: \"oklch\",\n        l: this.utility,\n        c: this.specificity * 0.322,\n        h: this.mediation * 360\n      });\n      return culori.formatHex(fixedColor);\n    }\n  }, {\n    key: \"getOpposite\",\n    value: function getOpposite() {\n      var newM = this.mediation + 0.5 > 1 ? this.mediation - 0.5 : this.mediation + 0.5;\n      var newS = this.specificity;\n      var newU = 0.5 - (this.utility - 0.5);\n      return new Idea().setFromCreation(newM, newS, newU);\n    }\n  }]);\n\n  return Idea;\n}();\nvar AVG_CHAR_VAL = 100; // each char is roughly 100, so loop every ~50 chars\n\nvar hashStringToRange = function hashStringToRange(str) {\n  var loop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 20;\n  var count = 0;\n\n  for (var i = 0; i < str.length; i++) {\n    count += str.substr(i, 1).charCodeAt(0);\n  }\n\n  var scaledLoop = loop * AVG_CHAR_VAL;\n  return count % scaledLoop / scaledLoop;\n};\n\nvar wrapNumber = function wrapNumber(num) {\n  var range = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;\n  return num % range / range;\n};","map":{"version":3,"sources":["/Users/dub_ceo/Desktop/spacesvr-starter/src/ideas/Builder12/layers/basis/classes/idea.ts"],"names":["culori","Idea","setFromCreation","m","s","u","mediation","specificity","utility","text","len","length","hashStringToRange","fixedColor","rgb","mode","l","c","h","formatHex","newM","newS","newU","AVG_CHAR_VAL","str","loop","count","i","substr","charCodeAt","scaledLoop","wrapNumber","num","range"],"mappings":";;;AAAA;AACA,OAAO,KAAKA,MAAZ,MAAwB,QAAxB;;AAGA;AACA;AACA;AACA;AACA,WAAaC,IAAb;AACE;AAIA;AAGA;AAIA;AAIA;AACmB;AACE;AACJ;AAEjB,kBAAc;AAAA;;AAAA;;AAAA;;AAAA;;AAAA;;AAAA;;AAAA;;AAAA;;AAAA;;AAAA;;AAAA;;AACZ,SAAKC,eAAL;AACA,WAAO,IAAP;AACD;;AAxBH;AAAA;AAAA,sCA0ByC;AAAA,UAAvBC,CAAuB,uEAAnB,CAAmB;AAAA,UAAhBC,CAAgB,uEAAZ,CAAY;AAAA,UAATC,CAAS,uEAAL,GAAK;AACrC,WAAKC,SAAL,GAAiBH,CAAjB;AACA,WAAKI,WAAL,GAAmBH,CAAnB;AACA,WAAKI,OAAL,GAAeH,CAAf;AAEA,aAAO,IAAP;AACD;AAhCH;AAAA;AAAA,mCAkCiBI,IAlCjB,EAkC+B;AAC3B,UAAMC,GAAG,GAAGD,IAAI,CAACE,MAAjB;AACA,WAAKL,SAAL,GAAiBM,iBAAiB,CAACH,IAAD,CAAlC;AACA,WAAKF,WAAL,GAAmB,CAAC,KAAKG,GAAG,IAAI,CAAP,GAAW,CAAX,GAAe,IAAIA,GAAxB,CAAD,IAAiC,GAApD;AAEA,aAAO,IAAP;AACD;AAxCH;AAAA;AAAA,kCA0CgBF,OA1ChB,EA0CiC;AAC7B,WAAKA,OAAL,GAAeA,OAAf;AAEA,aAAO,IAAP;AACD;AA9CH;AAAA;AAAA,6BAgDmB;AACf,UAAMK,UAAU,GAAGb,MAAM,CAACc,GAAP,CAAW;AAC5BC,QAAAA,IAAI,EAAE,OADsB;AAE5BC,QAAAA,CAAC,EAAE,KAAKR,OAFoB;AAG5BS,QAAAA,CAAC,EAAE,KAAKV,WAAL,GAAmB,KAHM;AAI5BW,QAAAA,CAAC,EAAE,KAAKZ,SAAL,GAAiB;AAJQ,OAAX,CAAnB;AAOA,aAAON,MAAM,CAACmB,SAAP,CAAiBN,UAAjB,CAAP;AACD;AAzDH;AAAA;AAAA,kCA2DsB;AAClB,UAAMO,IAAI,GACR,KAAKd,SAAL,GAAiB,GAAjB,GAAuB,CAAvB,GAA2B,KAAKA,SAAL,GAAiB,GAA5C,GAAkD,KAAKA,SAAL,GAAiB,GADrE;AAEA,UAAMe,IAAI,GAAG,KAAKd,WAAlB;AAEA,UAAMe,IAAI,GAAG,OAAO,KAAKd,OAAL,GAAe,GAAtB,CAAb;AACA,aAAO,IAAIP,IAAJ,GAAWC,eAAX,CAA2BkB,IAA3B,EAAiCC,IAAjC,EAAuCC,IAAvC,CAAP;AACD;AAlEH;;AAAA;AAAA;AAqEA,IAAMC,YAAY,GAAG,GAArB,C,CAA0B;;AAE1B,IAAMX,iBAAiB,GAAG,SAApBA,iBAAoB,CAACY,GAAD,EAAoC;AAAA,MAAtBC,IAAsB,uEAAf,EAAe;AAC5D,MAAIC,KAAK,GAAG,CAAZ;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,GAAG,CAACb,MAAxB,EAAgCgB,CAAC,EAAjC,EAAqC;AACnCD,IAAAA,KAAK,IAAIF,GAAG,CAACI,MAAJ,CAAWD,CAAX,EAAc,CAAd,EAAiBE,UAAjB,CAA4B,CAA5B,CAAT;AACD;;AACD,MAAMC,UAAU,GAAGL,IAAI,GAAGF,YAA1B;AACA,SAAQG,KAAK,GAAGI,UAAT,GAAuBA,UAA9B;AACD,CAPD;;AASA,IAAMC,UAAU,GAAG,SAAbA,UAAa,CAACC,GAAD,EAA6B;AAAA,MAAfC,KAAe,uEAAP,EAAO;AAC9C,SAAQD,GAAG,GAAGC,KAAP,GAAgBA,KAAvB;AACD,CAFD","sourcesContent":["// @ts-ignore\nimport * as culori from \"culori\";\nimport { NpmDependencies, Schema } from \"../types/idea\";\n\n/**\n * an idea is the fundamental atom of the ideal reality.\n * everything is an idea, whether the idea is accurately visualized or not.\n */\nexport class Idea {\n  // definition\n  id: string;\n  props: any;\n\n  // aliases\n  name: string;\n\n  // size\n  schema: Schema;\n  npm_dependencies: NpmDependencies;\n\n  // thought\n  purpose: string;\n  predecessor: string;\n\n  // mediation\n  mediation: number; // [0, 1)\n  specificity: number; // [0, 1]\n  utility: number; // [0, 1]\n\n  constructor() {\n    this.setFromCreation();\n    return this;\n  }\n\n  setFromCreation(m = 0, s = 0, u = 0.5) {\n    this.mediation = m;\n    this.specificity = s;\n    this.utility = u;\n\n    return this;\n  }\n\n  updateFromText(text: string) {\n    const len = text.length;\n    this.mediation = hashStringToRange(text);\n    this.specificity = (1 - (len == 0 ? 1 : 1 / len)) * 0.5;\n\n    return this;\n  }\n\n  updateUtility(utility: number) {\n    this.utility = utility;\n\n    return this;\n  }\n\n  getHex(): string {\n    const fixedColor = culori.rgb({\n      mode: \"oklch\",\n      l: this.utility,\n      c: this.specificity * 0.322,\n      h: this.mediation * 360,\n    });\n\n    return culori.formatHex(fixedColor);\n  }\n\n  getOpposite(): Idea {\n    const newM =\n      this.mediation + 0.5 > 1 ? this.mediation - 0.5 : this.mediation + 0.5;\n    const newS = this.specificity;\n\n    const newU = 0.5 - (this.utility - 0.5);\n    return new Idea().setFromCreation(newM, newS, newU);\n  }\n}\n\nconst AVG_CHAR_VAL = 100; // each char is roughly 100, so loop every ~50 chars\n\nconst hashStringToRange = (str: string, loop = 20): number => {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    count += str.substr(i, 1).charCodeAt(0);\n  }\n  const scaledLoop = loop * AVG_CHAR_VAL;\n  return (count % scaledLoop) / scaledLoop;\n};\n\nconst wrapNumber = (num: number, range = 10) => {\n  return (num % range) / range;\n};\n"]},"metadata":{},"sourceType":"module"}