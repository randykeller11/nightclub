{"ast":null,"code":"import { AnimationClip, AnimationMixer, Euler, Matrix4, Quaternion, QuaternionKeyframeTrack, SkeletonHelper, Vector2, Vector3, VectorKeyframeTrack } from \"three\";\nvar SkeletonUtils = {\n  retarget: function () {\n    var pos = new Vector3(),\n        quat = new Quaternion(),\n        scale = new Vector3(),\n        bindBoneMatrix = new Matrix4(),\n        relativeMatrix = new Matrix4(),\n        globalMatrix = new Matrix4();\n    return function (target, source, options) {\n      options = options || {};\n      options.preserveMatrix = options.preserveMatrix !== undefined ? options.preserveMatrix : true;\n      options.preservePosition = options.preservePosition !== undefined ? options.preservePosition : true;\n      options.preserveHipPosition = options.preserveHipPosition !== undefined ? options.preserveHipPosition : false;\n      options.useTargetMatrix = options.useTargetMatrix !== undefined ? options.useTargetMatrix : false;\n      options.hip = options.hip !== undefined ? options.hip : \"hip\";\n      options.names = options.names || {};\n      var sourceBones = source.isObject3D ? source.skeleton.bones : this.getBones(source),\n          bones = target.isObject3D ? target.skeleton.bones : this.getBones(target),\n          bindBones,\n          bone,\n          name,\n          boneTo,\n          bonesPosition,\n          i; // reset bones\n\n      if (target.isObject3D) {\n        target.skeleton.pose();\n      } else {\n        options.useTargetMatrix = true;\n        options.preserveMatrix = false;\n      }\n\n      if (options.preservePosition) {\n        bonesPosition = [];\n\n        for (i = 0; i < bones.length; i++) {\n          bonesPosition.push(bones[i].position.clone());\n        }\n      }\n\n      if (options.preserveMatrix) {\n        // reset matrix\n        target.updateMatrixWorld();\n        target.matrixWorld.identity(); // reset children matrix\n\n        for (i = 0; i < target.children.length; ++i) {\n          target.children[i].updateMatrixWorld(true);\n        }\n      }\n\n      if (options.offsets) {\n        bindBones = [];\n\n        for (i = 0; i < bones.length; ++i) {\n          bone = bones[i];\n          name = options.names[bone.name] || bone.name;\n\n          if (options.offsets && options.offsets[name]) {\n            bone.matrix.multiply(options.offsets[name]);\n            bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n            bone.updateMatrixWorld();\n          }\n\n          bindBones.push(bone.matrixWorld.clone());\n        }\n      }\n\n      for (i = 0; i < bones.length; ++i) {\n        bone = bones[i];\n        name = options.names[bone.name] || bone.name;\n        boneTo = this.getBoneByName(name, sourceBones);\n        globalMatrix.copy(bone.matrixWorld);\n\n        if (boneTo) {\n          boneTo.updateMatrixWorld();\n\n          if (options.useTargetMatrix) {\n            relativeMatrix.copy(boneTo.matrixWorld);\n          } else {\n            relativeMatrix.copy(target.matrixWorld).invert();\n            relativeMatrix.multiply(boneTo.matrixWorld);\n          } // ignore scale to extract rotation\n\n\n          scale.setFromMatrixScale(relativeMatrix);\n          relativeMatrix.scale(scale.set(1 / scale.x, 1 / scale.y, 1 / scale.z)); // apply to global matrix\n\n          globalMatrix.makeRotationFromQuaternion(quat.setFromRotationMatrix(relativeMatrix));\n\n          if (target.isObject3D) {\n            var boneIndex = bones.indexOf(bone),\n                wBindMatrix = bindBones ? bindBones[boneIndex] : bindBoneMatrix.copy(target.skeleton.boneInverses[boneIndex]).invert();\n            globalMatrix.multiply(wBindMatrix);\n          }\n\n          globalMatrix.copyPosition(relativeMatrix);\n        }\n\n        if (bone.parent && bone.parent.isBone) {\n          bone.matrix.copy(bone.parent.matrixWorld).invert();\n          bone.matrix.multiply(globalMatrix);\n        } else {\n          bone.matrix.copy(globalMatrix);\n        }\n\n        if (options.preserveHipPosition && name === options.hip) {\n          bone.matrix.setPosition(pos.set(0, bone.position.y, 0));\n        }\n\n        bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n        bone.updateMatrixWorld();\n      }\n\n      if (options.preservePosition) {\n        for (i = 0; i < bones.length; ++i) {\n          bone = bones[i];\n          name = options.names[bone.name] || bone.name;\n\n          if (name !== options.hip) {\n            bone.position.copy(bonesPosition[i]);\n          }\n        }\n      }\n\n      if (options.preserveMatrix) {\n        // restore matrix\n        target.updateMatrixWorld(true);\n      }\n    };\n  }(),\n  retargetClip: function retargetClip(target, source, clip, options) {\n    options = options || {};\n    options.useFirstFramePosition = options.useFirstFramePosition !== undefined ? options.useFirstFramePosition : false;\n    options.fps = options.fps !== undefined ? options.fps : 30;\n    options.names = options.names || [];\n\n    if (!source.isObject3D) {\n      source = this.getHelperFromSkeleton(source);\n    }\n\n    var numFrames = Math.round(clip.duration * (options.fps / 1000) * 1000),\n        delta = 1 / options.fps,\n        convertedTracks = [],\n        mixer = new AnimationMixer(source),\n        bones = this.getBones(target.skeleton),\n        boneDatas = [],\n        positionOffset,\n        bone,\n        boneTo,\n        boneData,\n        name,\n        i,\n        j;\n    mixer.clipAction(clip).play();\n    mixer.update(0);\n    source.updateMatrixWorld();\n\n    for (i = 0; i < numFrames; ++i) {\n      var time = i * delta;\n      this.retarget(target, source, options);\n\n      for (j = 0; j < bones.length; ++j) {\n        name = options.names[bones[j].name] || bones[j].name;\n        boneTo = this.getBoneByName(name, source.skeleton);\n\n        if (boneTo) {\n          bone = bones[j];\n          boneData = boneDatas[j] = boneDatas[j] || {\n            bone: bone\n          };\n\n          if (options.hip === name) {\n            if (!boneData.pos) {\n              boneData.pos = {\n                times: new Float32Array(numFrames),\n                values: new Float32Array(numFrames * 3)\n              };\n            }\n\n            if (options.useFirstFramePosition) {\n              if (i === 0) {\n                positionOffset = bone.position.clone();\n              }\n\n              bone.position.sub(positionOffset);\n            }\n\n            boneData.pos.times[i] = time;\n            bone.position.toArray(boneData.pos.values, i * 3);\n          }\n\n          if (!boneData.quat) {\n            boneData.quat = {\n              times: new Float32Array(numFrames),\n              values: new Float32Array(numFrames * 4)\n            };\n          }\n\n          boneData.quat.times[i] = time;\n          bone.quaternion.toArray(boneData.quat.values, i * 4);\n        }\n      }\n\n      mixer.update(delta);\n      source.updateMatrixWorld();\n    }\n\n    for (i = 0; i < boneDatas.length; ++i) {\n      boneData = boneDatas[i];\n\n      if (boneData) {\n        if (boneData.pos) {\n          convertedTracks.push(new VectorKeyframeTrack(\".bones[\" + boneData.bone.name + \"].position\", boneData.pos.times, boneData.pos.values));\n        }\n\n        convertedTracks.push(new QuaternionKeyframeTrack(\".bones[\" + boneData.bone.name + \"].quaternion\", boneData.quat.times, boneData.quat.values));\n      }\n    }\n\n    mixer.uncacheAction(clip);\n    return new AnimationClip(clip.name, -1, convertedTracks);\n  },\n  getHelperFromSkeleton: function getHelperFromSkeleton(skeleton) {\n    var source = new SkeletonHelper(skeleton.bones[0]);\n    source.skeleton = skeleton;\n    return source;\n  },\n  getSkeletonOffsets: function () {\n    var targetParentPos = new Vector3(),\n        targetPos = new Vector3(),\n        sourceParentPos = new Vector3(),\n        sourcePos = new Vector3(),\n        targetDir = new Vector2(),\n        sourceDir = new Vector2();\n    return function (target, source, options) {\n      options = options || {};\n      options.hip = options.hip !== undefined ? options.hip : \"hip\";\n      options.names = options.names || {};\n\n      if (!source.isObject3D) {\n        source = this.getHelperFromSkeleton(source);\n      }\n\n      var nameKeys = Object.keys(options.names),\n          nameValues = Object.values(options.names),\n          sourceBones = source.isObject3D ? source.skeleton.bones : this.getBones(source),\n          bones = target.isObject3D ? target.skeleton.bones : this.getBones(target),\n          offsets = [],\n          bone,\n          boneTo,\n          name,\n          i;\n      target.skeleton.pose();\n\n      for (i = 0; i < bones.length; ++i) {\n        bone = bones[i];\n        name = options.names[bone.name] || bone.name;\n        boneTo = this.getBoneByName(name, sourceBones);\n\n        if (boneTo && name !== options.hip) {\n          var boneParent = this.getNearestBone(bone.parent, nameKeys),\n              boneToParent = this.getNearestBone(boneTo.parent, nameValues);\n          boneParent.updateMatrixWorld();\n          boneToParent.updateMatrixWorld();\n          targetParentPos.setFromMatrixPosition(boneParent.matrixWorld);\n          targetPos.setFromMatrixPosition(bone.matrixWorld);\n          sourceParentPos.setFromMatrixPosition(boneToParent.matrixWorld);\n          sourcePos.setFromMatrixPosition(boneTo.matrixWorld);\n          targetDir.subVectors(new Vector2(targetPos.x, targetPos.y), new Vector2(targetParentPos.x, targetParentPos.y)).normalize();\n          sourceDir.subVectors(new Vector2(sourcePos.x, sourcePos.y), new Vector2(sourceParentPos.x, sourceParentPos.y)).normalize();\n          var laterialAngle = targetDir.angle() - sourceDir.angle();\n          var offset = new Matrix4().makeRotationFromEuler(new Euler(0, 0, laterialAngle));\n          bone.matrix.multiply(offset);\n          bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n          bone.updateMatrixWorld();\n          offsets[name] = offset;\n        }\n      }\n\n      return offsets;\n    };\n  }(),\n  renameBones: function renameBones(skeleton, names) {\n    var bones = this.getBones(skeleton);\n\n    for (var i = 0; i < bones.length; ++i) {\n      var bone = bones[i];\n\n      if (names[bone.name]) {\n        bone.name = names[bone.name];\n      }\n    }\n\n    return this;\n  },\n  getBones: function getBones(skeleton) {\n    return Array.isArray(skeleton) ? skeleton : skeleton.bones;\n  },\n  getBoneByName: function getBoneByName(name, skeleton) {\n    for (var i = 0, bones = this.getBones(skeleton); i < bones.length; i++) {\n      if (name === bones[i].name) return bones[i];\n    }\n  },\n  getNearestBone: function getNearestBone(bone, names) {\n    while (bone.isBone) {\n      if (names.indexOf(bone.name) !== -1) {\n        return bone;\n      }\n\n      bone = bone.parent;\n    }\n  },\n  findBoneTrackData: function findBoneTrackData(name, tracks) {\n    var regexp = /\\[(.*)\\]\\.(.*)/,\n        result = {\n      name: name\n    };\n\n    for (var i = 0; i < tracks.length; ++i) {\n      // 1 is track name\n      // 2 is track type\n      var trackData = regexp.exec(tracks[i].name);\n\n      if (trackData && name === trackData[1]) {\n        result[trackData[2]] = i;\n      }\n    }\n\n    return result;\n  },\n  getEqualsBonesNames: function getEqualsBonesNames(skeleton, targetSkeleton) {\n    var sourceBones = this.getBones(skeleton),\n        targetBones = this.getBones(targetSkeleton),\n        bones = [];\n\n    search: for (var i = 0; i < sourceBones.length; i++) {\n      var boneName = sourceBones[i].name;\n\n      for (var j = 0; j < targetBones.length; j++) {\n        if (boneName === targetBones[j].name) {\n          bones.push(boneName);\n          continue search;\n        }\n      }\n    }\n\n    return bones;\n  },\n  clone: function clone(source) {\n    var sourceLookup = new Map();\n    var cloneLookup = new Map();\n    var clone = source.clone();\n    parallelTraverse(source, clone, function (sourceNode, clonedNode) {\n      sourceLookup.set(clonedNode, sourceNode);\n      cloneLookup.set(sourceNode, clonedNode);\n    });\n    clone.traverse(function (node) {\n      if (!node.isSkinnedMesh) return;\n      var clonedMesh = node;\n      var sourceMesh = sourceLookup.get(node);\n      var sourceBones = sourceMesh.skeleton.bones;\n      clonedMesh.skeleton = sourceMesh.skeleton.clone();\n      clonedMesh.bindMatrix.copy(sourceMesh.bindMatrix);\n      clonedMesh.skeleton.bones = sourceBones.map(function (bone) {\n        return cloneLookup.get(bone);\n      });\n      clonedMesh.bind(clonedMesh.skeleton, clonedMesh.bindMatrix);\n    });\n    return clone;\n  }\n};\n\nfunction parallelTraverse(a, b, callback) {\n  callback(a, b);\n\n  for (var i = 0; i < a.children.length; i++) {\n    parallelTraverse(a.children[i], b.children[i], callback);\n  }\n}\n\nexport { SkeletonUtils };","map":{"version":3,"sources":["/Users/dub_ceo/Desktop/spacesvr-starter/src/ideas/Builder12/utils/SkeletonUtils.js"],"names":["AnimationClip","AnimationMixer","Euler","Matrix4","Quaternion","QuaternionKeyframeTrack","SkeletonHelper","Vector2","Vector3","VectorKeyframeTrack","SkeletonUtils","retarget","pos","quat","scale","bindBoneMatrix","relativeMatrix","globalMatrix","target","source","options","preserveMatrix","undefined","preservePosition","preserveHipPosition","useTargetMatrix","hip","names","sourceBones","isObject3D","skeleton","bones","getBones","bindBones","bone","name","boneTo","bonesPosition","i","pose","length","push","position","clone","updateMatrixWorld","matrixWorld","identity","children","offsets","matrix","multiply","decompose","quaternion","getBoneByName","copy","invert","setFromMatrixScale","set","x","y","z","makeRotationFromQuaternion","setFromRotationMatrix","boneIndex","indexOf","wBindMatrix","boneInverses","copyPosition","parent","isBone","setPosition","retargetClip","clip","useFirstFramePosition","fps","getHelperFromSkeleton","numFrames","Math","round","duration","delta","convertedTracks","mixer","boneDatas","positionOffset","boneData","j","clipAction","play","update","time","times","Float32Array","values","sub","toArray","uncacheAction","getSkeletonOffsets","targetParentPos","targetPos","sourceParentPos","sourcePos","targetDir","sourceDir","nameKeys","Object","keys","nameValues","boneParent","getNearestBone","boneToParent","setFromMatrixPosition","subVectors","normalize","laterialAngle","angle","offset","makeRotationFromEuler","renameBones","Array","isArray","findBoneTrackData","tracks","regexp","result","trackData","exec","getEqualsBonesNames","targetSkeleton","targetBones","search","boneName","sourceLookup","Map","cloneLookup","parallelTraverse","sourceNode","clonedNode","traverse","node","isSkinnedMesh","clonedMesh","sourceMesh","get","bindMatrix","map","bind","a","b","callback"],"mappings":"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","sourcesContent":["import {\n  AnimationClip,\n  AnimationMixer,\n  Euler,\n  Matrix4,\n  Quaternion,\n  QuaternionKeyframeTrack,\n  SkeletonHelper,\n  Vector2,\n  Vector3,\n  VectorKeyframeTrack,\n} from \"three\";\n\nvar SkeletonUtils = {\n  retarget: (function () {\n    var pos = new Vector3(),\n      quat = new Quaternion(),\n      scale = new Vector3(),\n      bindBoneMatrix = new Matrix4(),\n      relativeMatrix = new Matrix4(),\n      globalMatrix = new Matrix4();\n\n    return function (target, source, options) {\n      options = options || {};\n      options.preserveMatrix =\n        options.preserveMatrix !== undefined ? options.preserveMatrix : true;\n      options.preservePosition =\n        options.preservePosition !== undefined\n          ? options.preservePosition\n          : true;\n      options.preserveHipPosition =\n        options.preserveHipPosition !== undefined\n          ? options.preserveHipPosition\n          : false;\n      options.useTargetMatrix =\n        options.useTargetMatrix !== undefined ? options.useTargetMatrix : false;\n      options.hip = options.hip !== undefined ? options.hip : \"hip\";\n      options.names = options.names || {};\n\n      var sourceBones = source.isObject3D\n          ? source.skeleton.bones\n          : this.getBones(source),\n        bones = target.isObject3D\n          ? target.skeleton.bones\n          : this.getBones(target),\n        bindBones,\n        bone,\n        name,\n        boneTo,\n        bonesPosition,\n        i;\n\n      // reset bones\n\n      if (target.isObject3D) {\n        target.skeleton.pose();\n      } else {\n        options.useTargetMatrix = true;\n        options.preserveMatrix = false;\n      }\n\n      if (options.preservePosition) {\n        bonesPosition = [];\n\n        for (i = 0; i < bones.length; i++) {\n          bonesPosition.push(bones[i].position.clone());\n        }\n      }\n\n      if (options.preserveMatrix) {\n        // reset matrix\n\n        target.updateMatrixWorld();\n\n        target.matrixWorld.identity();\n\n        // reset children matrix\n\n        for (i = 0; i < target.children.length; ++i) {\n          target.children[i].updateMatrixWorld(true);\n        }\n      }\n\n      if (options.offsets) {\n        bindBones = [];\n\n        for (i = 0; i < bones.length; ++i) {\n          bone = bones[i];\n          name = options.names[bone.name] || bone.name;\n\n          if (options.offsets && options.offsets[name]) {\n            bone.matrix.multiply(options.offsets[name]);\n\n            bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n\n            bone.updateMatrixWorld();\n          }\n\n          bindBones.push(bone.matrixWorld.clone());\n        }\n      }\n\n      for (i = 0; i < bones.length; ++i) {\n        bone = bones[i];\n        name = options.names[bone.name] || bone.name;\n\n        boneTo = this.getBoneByName(name, sourceBones);\n\n        globalMatrix.copy(bone.matrixWorld);\n\n        if (boneTo) {\n          boneTo.updateMatrixWorld();\n\n          if (options.useTargetMatrix) {\n            relativeMatrix.copy(boneTo.matrixWorld);\n          } else {\n            relativeMatrix.copy(target.matrixWorld).invert();\n            relativeMatrix.multiply(boneTo.matrixWorld);\n          }\n\n          // ignore scale to extract rotation\n\n          scale.setFromMatrixScale(relativeMatrix);\n          relativeMatrix.scale(\n            scale.set(1 / scale.x, 1 / scale.y, 1 / scale.z)\n          );\n\n          // apply to global matrix\n\n          globalMatrix.makeRotationFromQuaternion(\n            quat.setFromRotationMatrix(relativeMatrix)\n          );\n\n          if (target.isObject3D) {\n            var boneIndex = bones.indexOf(bone),\n              wBindMatrix = bindBones\n                ? bindBones[boneIndex]\n                : bindBoneMatrix\n                    .copy(target.skeleton.boneInverses[boneIndex])\n                    .invert();\n\n            globalMatrix.multiply(wBindMatrix);\n          }\n\n          globalMatrix.copyPosition(relativeMatrix);\n        }\n\n        if (bone.parent && bone.parent.isBone) {\n          bone.matrix.copy(bone.parent.matrixWorld).invert();\n          bone.matrix.multiply(globalMatrix);\n        } else {\n          bone.matrix.copy(globalMatrix);\n        }\n\n        if (options.preserveHipPosition && name === options.hip) {\n          bone.matrix.setPosition(pos.set(0, bone.position.y, 0));\n        }\n\n        bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n\n        bone.updateMatrixWorld();\n      }\n\n      if (options.preservePosition) {\n        for (i = 0; i < bones.length; ++i) {\n          bone = bones[i];\n          name = options.names[bone.name] || bone.name;\n\n          if (name !== options.hip) {\n            bone.position.copy(bonesPosition[i]);\n          }\n        }\n      }\n\n      if (options.preserveMatrix) {\n        // restore matrix\n\n        target.updateMatrixWorld(true);\n      }\n    };\n  })(),\n\n  retargetClip: function (target, source, clip, options) {\n    options = options || {};\n    options.useFirstFramePosition =\n      options.useFirstFramePosition !== undefined\n        ? options.useFirstFramePosition\n        : false;\n    options.fps = options.fps !== undefined ? options.fps : 30;\n    options.names = options.names || [];\n\n    if (!source.isObject3D) {\n      source = this.getHelperFromSkeleton(source);\n    }\n\n    var numFrames = Math.round(clip.duration * (options.fps / 1000) * 1000),\n      delta = 1 / options.fps,\n      convertedTracks = [],\n      mixer = new AnimationMixer(source),\n      bones = this.getBones(target.skeleton),\n      boneDatas = [],\n      positionOffset,\n      bone,\n      boneTo,\n      boneData,\n      name,\n      i,\n      j;\n\n    mixer.clipAction(clip).play();\n    mixer.update(0);\n\n    source.updateMatrixWorld();\n\n    for (i = 0; i < numFrames; ++i) {\n      var time = i * delta;\n\n      this.retarget(target, source, options);\n\n      for (j = 0; j < bones.length; ++j) {\n        name = options.names[bones[j].name] || bones[j].name;\n\n        boneTo = this.getBoneByName(name, source.skeleton);\n\n        if (boneTo) {\n          bone = bones[j];\n          boneData = boneDatas[j] = boneDatas[j] || { bone: bone };\n\n          if (options.hip === name) {\n            if (!boneData.pos) {\n              boneData.pos = {\n                times: new Float32Array(numFrames),\n                values: new Float32Array(numFrames * 3),\n              };\n            }\n\n            if (options.useFirstFramePosition) {\n              if (i === 0) {\n                positionOffset = bone.position.clone();\n              }\n\n              bone.position.sub(positionOffset);\n            }\n\n            boneData.pos.times[i] = time;\n\n            bone.position.toArray(boneData.pos.values, i * 3);\n          }\n\n          if (!boneData.quat) {\n            boneData.quat = {\n              times: new Float32Array(numFrames),\n              values: new Float32Array(numFrames * 4),\n            };\n          }\n\n          boneData.quat.times[i] = time;\n\n          bone.quaternion.toArray(boneData.quat.values, i * 4);\n        }\n      }\n\n      mixer.update(delta);\n\n      source.updateMatrixWorld();\n    }\n\n    for (i = 0; i < boneDatas.length; ++i) {\n      boneData = boneDatas[i];\n\n      if (boneData) {\n        if (boneData.pos) {\n          convertedTracks.push(\n            new VectorKeyframeTrack(\n              \".bones[\" + boneData.bone.name + \"].position\",\n              boneData.pos.times,\n              boneData.pos.values\n            )\n          );\n        }\n\n        convertedTracks.push(\n          new QuaternionKeyframeTrack(\n            \".bones[\" + boneData.bone.name + \"].quaternion\",\n            boneData.quat.times,\n            boneData.quat.values\n          )\n        );\n      }\n    }\n\n    mixer.uncacheAction(clip);\n\n    return new AnimationClip(clip.name, -1, convertedTracks);\n  },\n\n  getHelperFromSkeleton: function (skeleton) {\n    var source = new SkeletonHelper(skeleton.bones[0]);\n    source.skeleton = skeleton;\n\n    return source;\n  },\n\n  getSkeletonOffsets: (function () {\n    var targetParentPos = new Vector3(),\n      targetPos = new Vector3(),\n      sourceParentPos = new Vector3(),\n      sourcePos = new Vector3(),\n      targetDir = new Vector2(),\n      sourceDir = new Vector2();\n\n    return function (target, source, options) {\n      options = options || {};\n      options.hip = options.hip !== undefined ? options.hip : \"hip\";\n      options.names = options.names || {};\n\n      if (!source.isObject3D) {\n        source = this.getHelperFromSkeleton(source);\n      }\n\n      var nameKeys = Object.keys(options.names),\n        nameValues = Object.values(options.names),\n        sourceBones = source.isObject3D\n          ? source.skeleton.bones\n          : this.getBones(source),\n        bones = target.isObject3D\n          ? target.skeleton.bones\n          : this.getBones(target),\n        offsets = [],\n        bone,\n        boneTo,\n        name,\n        i;\n\n      target.skeleton.pose();\n\n      for (i = 0; i < bones.length; ++i) {\n        bone = bones[i];\n        name = options.names[bone.name] || bone.name;\n\n        boneTo = this.getBoneByName(name, sourceBones);\n\n        if (boneTo && name !== options.hip) {\n          var boneParent = this.getNearestBone(bone.parent, nameKeys),\n            boneToParent = this.getNearestBone(boneTo.parent, nameValues);\n\n          boneParent.updateMatrixWorld();\n          boneToParent.updateMatrixWorld();\n\n          targetParentPos.setFromMatrixPosition(boneParent.matrixWorld);\n          targetPos.setFromMatrixPosition(bone.matrixWorld);\n\n          sourceParentPos.setFromMatrixPosition(boneToParent.matrixWorld);\n          sourcePos.setFromMatrixPosition(boneTo.matrixWorld);\n\n          targetDir\n            .subVectors(\n              new Vector2(targetPos.x, targetPos.y),\n              new Vector2(targetParentPos.x, targetParentPos.y)\n            )\n            .normalize();\n\n          sourceDir\n            .subVectors(\n              new Vector2(sourcePos.x, sourcePos.y),\n              new Vector2(sourceParentPos.x, sourceParentPos.y)\n            )\n            .normalize();\n\n          var laterialAngle = targetDir.angle() - sourceDir.angle();\n\n          var offset = new Matrix4().makeRotationFromEuler(\n            new Euler(0, 0, laterialAngle)\n          );\n\n          bone.matrix.multiply(offset);\n\n          bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n\n          bone.updateMatrixWorld();\n\n          offsets[name] = offset;\n        }\n      }\n\n      return offsets;\n    };\n  })(),\n\n  renameBones: function (skeleton, names) {\n    var bones = this.getBones(skeleton);\n\n    for (var i = 0; i < bones.length; ++i) {\n      var bone = bones[i];\n\n      if (names[bone.name]) {\n        bone.name = names[bone.name];\n      }\n    }\n\n    return this;\n  },\n\n  getBones: function (skeleton) {\n    return Array.isArray(skeleton) ? skeleton : skeleton.bones;\n  },\n\n  getBoneByName: function (name, skeleton) {\n    for (var i = 0, bones = this.getBones(skeleton); i < bones.length; i++) {\n      if (name === bones[i].name) return bones[i];\n    }\n  },\n\n  getNearestBone: function (bone, names) {\n    while (bone.isBone) {\n      if (names.indexOf(bone.name) !== -1) {\n        return bone;\n      }\n\n      bone = bone.parent;\n    }\n  },\n\n  findBoneTrackData: function (name, tracks) {\n    var regexp = /\\[(.*)\\]\\.(.*)/,\n      result = { name: name };\n\n    for (var i = 0; i < tracks.length; ++i) {\n      // 1 is track name\n      // 2 is track type\n      var trackData = regexp.exec(tracks[i].name);\n\n      if (trackData && name === trackData[1]) {\n        result[trackData[2]] = i;\n      }\n    }\n\n    return result;\n  },\n\n  getEqualsBonesNames: function (skeleton, targetSkeleton) {\n    var sourceBones = this.getBones(skeleton),\n      targetBones = this.getBones(targetSkeleton),\n      bones = [];\n\n    search: for (var i = 0; i < sourceBones.length; i++) {\n      var boneName = sourceBones[i].name;\n\n      for (var j = 0; j < targetBones.length; j++) {\n        if (boneName === targetBones[j].name) {\n          bones.push(boneName);\n\n          continue search;\n        }\n      }\n    }\n\n    return bones;\n  },\n\n  clone: function (source) {\n    var sourceLookup = new Map();\n    var cloneLookup = new Map();\n\n    var clone = source.clone();\n\n    parallelTraverse(source, clone, function (sourceNode, clonedNode) {\n      sourceLookup.set(clonedNode, sourceNode);\n      cloneLookup.set(sourceNode, clonedNode);\n    });\n\n    clone.traverse(function (node) {\n      if (!node.isSkinnedMesh) return;\n\n      var clonedMesh = node;\n      var sourceMesh = sourceLookup.get(node);\n      var sourceBones = sourceMesh.skeleton.bones;\n\n      clonedMesh.skeleton = sourceMesh.skeleton.clone();\n      clonedMesh.bindMatrix.copy(sourceMesh.bindMatrix);\n\n      clonedMesh.skeleton.bones = sourceBones.map(function (bone) {\n        return cloneLookup.get(bone);\n      });\n\n      clonedMesh.bind(clonedMesh.skeleton, clonedMesh.bindMatrix);\n    });\n\n    return clone;\n  },\n};\n\nfunction parallelTraverse(a, b, callback) {\n  callback(a, b);\n\n  for (var i = 0; i < a.children.length; i++) {\n    parallelTraverse(a.children[i], b.children[i], callback);\n  }\n}\n\nexport { SkeletonUtils };\n"]},"metadata":{},"sourceType":"module"}