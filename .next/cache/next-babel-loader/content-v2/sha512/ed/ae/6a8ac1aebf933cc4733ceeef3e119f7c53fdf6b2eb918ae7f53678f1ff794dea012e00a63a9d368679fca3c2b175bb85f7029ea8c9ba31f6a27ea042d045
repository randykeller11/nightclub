{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { DoubleSide, ShaderMaterial, Uniform } from \"three\";\nimport { useMemo } from \"react\";\nimport { useLimiter } from \"spacesvr\";\nimport { useFrame } from \"@react-three/fiber\";\nexport var useSkyMat = function useSkyMat(radius, colors) {\n  _s();\n\n  var mat = useMemo(function () {\n    return new ShaderMaterial({\n      uniforms: {\n        radius: new Uniform(radius),\n        colors: new Uniform(colors),\n        num_colors: new Uniform(colors.length),\n        time: new Uniform(0)\n      },\n      vertexShader: vert,\n      fragmentShader: frag,\n      side: DoubleSide\n    });\n  }, [radius, colors]);\n  var limiter = useLimiter(30);\n  useFrame(function (_ref) {\n    var clock = _ref.clock;\n    if (!mat || !limiter.isReady(clock)) return; // @ts-ignore\n\n    mat.uniforms.time.value = new Date() / 1000 % 10000 / 5;\n  });\n  return mat;\n};\n\n_s(useSkyMat, \"tSSf8E0WlYfLVPLrjj0rUcV7Evg=\", false, function () {\n  return [useLimiter, useFrame];\n});\n\nvar vert = \"\\n    varying vec3 absPosition;\\n    void main() {\\n        absPosition = position;\\n        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n    }\\n\";\nvar frag = \"\\n  uniform highp float radius;\\n  uniform highp float time;\\n  uniform int num_colors;\\n  uniform highp float colors[100];\\n  varying vec3 absPosition;\\n  \\n  //\\n  // Description : Array and textureless GLSL 2D/3D/4D simplex\\n  //               noise functions.\\n  //      Author : Ian McEwan, Ashima Arts.\\n  //  Maintainer : ijm\\n  //     Lastmod : 20110822 (ijm)\\n  //     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\\n  //               Distributed under the MIT License. See LICENSE file.\\n  //               https://github.com/ashima/webgl-noise\\n  //\\n  \\n  vec3 mod289(vec3 x) {\\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\\n  }\\n  \\n  vec4 mod289(vec4 x) {\\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\\n  }\\n  \\n  vec4 permute(vec4 x) {\\n       return mod289(((x*34.0)+1.0)*x);\\n  }\\n  \\n  vec4 taylorInvSqrt(vec4 r)\\n  {\\n    return 1.79284291400159 - 0.85373472095314 * r;\\n  }\\n  \\n  float snoise(vec3 v)\\n    {\\n    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\\n    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\\n  \\n  // First corner\\n    vec3 i  = floor(v + dot(v, C.yyy) );\\n    vec3 x0 =   v - i + dot(i, C.xxx) ;\\n  \\n  // Other corners\\n    vec3 g = step(x0.yzx, x0.xyz);\\n    vec3 l = 1.0 - g;\\n    vec3 i1 = min( g.xyz, l.zxy );\\n    vec3 i2 = max( g.xyz, l.zxy );\\n  \\n    //   x0 = x0 - 0.0 + 0.0 * C.xxx;\\n    //   x1 = x0 - i1  + 1.0 * C.xxx;\\n    //   x2 = x0 - i2  + 2.0 * C.xxx;\\n    //   x3 = x0 - 1.0 + 3.0 * C.xxx;\\n    vec3 x1 = x0 - i1 + C.xxx;\\n    vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\\n    vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\\n  \\n  // Permutations\\n    i = mod289(i);\\n    vec4 p = permute( permute( permute(\\n               i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\\n             + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\\n             + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\\n  \\n  // Gradients: 7x7 points over a square, mapped onto an octahedron.\\n  // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\\n    float n_ = 0.142857142857; // 1.0/7.0\\n    vec3  ns = n_ * D.wyz - D.xzx;\\n  \\n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\\n  \\n    vec4 x_ = floor(j * ns.z);\\n    vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\\n  \\n    vec4 x = x_ *ns.x + ns.yyyy;\\n    vec4 y = y_ *ns.x + ns.yyyy;\\n    vec4 h = 1.0 - abs(x) - abs(y);\\n  \\n    vec4 b0 = vec4( x.xy, y.xy );\\n    vec4 b1 = vec4( x.zw, y.zw );\\n  \\n    //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\\n    //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\\n    vec4 s0 = floor(b0)*2.0 + 1.0;\\n    vec4 s1 = floor(b1)*2.0 + 1.0;\\n    vec4 sh = -step(h, vec4(0.0));\\n  \\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\\n  \\n    vec3 p0 = vec3(a0.xy,h.x);\\n    vec3 p1 = vec3(a0.zw,h.y);\\n    vec3 p2 = vec3(a1.xy,h.z);\\n    vec3 p3 = vec3(a1.zw,h.w);\\n  \\n  //Normalise gradients\\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\\n    p0 *= norm.x;\\n    p1 *= norm.y;\\n    p2 *= norm.z;\\n    p3 *= norm.w;\\n  \\n  // Mix final noise value\\n    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\\n    m = m * m;\\n    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\\n                                  dot(p2,x2), dot(p3,x3) ) );\\n    } \\n  \\n  float get_mix(int index, float noise) { \\n    highp float lastPerc = float(index*3 - 1) / float(num_colors);\\n    highp float thisPerc = float(index*3) / float(num_colors);\\n    highp float height = ((absPosition.y + radius) / 2.) / (radius);\\n    return smoothstep(lastPerc, thisPerc, height + noise * 0.1);\\n  }\\n\\n  void main() {\\n    highp float yCoord = (gl_FragCoord.y / gl_FragCoord.w);\\n    highp float height = ((absPosition.y + radius) / 2.) / (radius);\\n    \\n    highp float noise_smooth = snoise((absPosition * 0.01)+ time*0.1);\\n    highp float noise_rough = snoise((absPosition * 0.1)+ time*0.45);\\n    \\n\\n    // color 0\\n    vec3 color = vec3(colors[0], colors[1], colors[2]);\\n    \\n    // color 1\\n    highp float noise1 = noise_smooth * 2. + noise_rough * 0.2;\\n    color = mix(color, vec3(colors[3], colors[4], colors[5]), get_mix(1, noise1));\\n\\n    // color 2\\n    highp float noise2 = noise_smooth * 4. + noise_rough * 0.2;\\n    color = mix(color, vec3(colors[6], colors[7], colors[8]), get_mix(2, noise2));\\n\\n    // color 3\\n    highp float noise3 = noise_smooth * 1.5 + noise_rough * 0.8;\\n    color = mix(color, vec3(colors[9], colors[10], colors[11]), get_mix(3, noise3));\\n\\n    gl_FragColor = vec4( color, 1.0 );\\n  }\\n\";","map":{"version":3,"sources":["/Users/dub_ceo/Desktop/spacesvr-starter/src/ideas/CloudySky/materials/sky.ts"],"names":["DoubleSide","ShaderMaterial","Uniform","useMemo","useLimiter","useFrame","useSkyMat","radius","colors","mat","uniforms","num_colors","length","time","vertexShader","vert","fragmentShader","frag","side","limiter","clock","isReady","value","Date"],"mappings":";;AAAA,SAASA,UAAT,EAAqBC,cAArB,EAAqCC,OAArC,QAAoD,OAApD;AACA,SAASC,OAAT,QAAwB,OAAxB;AACA,SAASC,UAAT,QAA2B,UAA3B;AACA,SAASC,QAAT,QAAyB,oBAAzB;AAEA,OAAO,IAAMC,SAAS,GAAG,SAAZA,SAAY,CAACC,MAAD,EAAiBC,MAAjB,EAAsD;AAAA;;AAC7E,MAAMC,GAAG,GAAGN,OAAO,CACjB;AAAA,WACE,IAAIF,cAAJ,CAAmB;AACjBS,MAAAA,QAAQ,EAAE;AACRH,QAAAA,MAAM,EAAE,IAAIL,OAAJ,CAAYK,MAAZ,CADA;AAERC,QAAAA,MAAM,EAAE,IAAIN,OAAJ,CAAYM,MAAZ,CAFA;AAGRG,QAAAA,UAAU,EAAE,IAAIT,OAAJ,CAAYM,MAAM,CAACI,MAAnB,CAHJ;AAIRC,QAAAA,IAAI,EAAE,IAAIX,OAAJ,CAAY,CAAZ;AAJE,OADO;AAOjBY,MAAAA,YAAY,EAAEC,IAPG;AAQjBC,MAAAA,cAAc,EAAEC,IARC;AASjBC,MAAAA,IAAI,EAAElB;AATW,KAAnB,CADF;AAAA,GADiB,EAajB,CAACO,MAAD,EAASC,MAAT,CAbiB,CAAnB;AAgBA,MAAMW,OAAO,GAAGf,UAAU,CAAC,EAAD,CAA1B;AACAC,EAAAA,QAAQ,CAAC,gBAAe;AAAA,QAAZe,KAAY,QAAZA,KAAY;AACtB,QAAI,CAACX,GAAD,IAAQ,CAACU,OAAO,CAACE,OAAR,CAAgBD,KAAhB,CAAb,EAAqC,OADf,CAGtB;;AACAX,IAAAA,GAAG,CAACC,QAAJ,CAAaG,IAAb,CAAkBS,KAAlB,GAA4B,IAAIC,IAAJ,KAAa,IAAd,GAAsB,KAAvB,GAAgC,CAA1D;AACD,GALO,CAAR;AAOA,SAAOd,GAAP;AACD,CA1BM;;GAAMH,S;UAiBKF,U,EAChBC,Q;;;AAUF,IAAMU,IAAI,oLAAV;AAQA,IAAME,IAAI,89IAAV","sourcesContent":["import { DoubleSide, ShaderMaterial, Uniform } from \"three\";\nimport { useMemo } from \"react\";\nimport { useLimiter } from \"spacesvr\";\nimport { useFrame } from \"@react-three/fiber\";\n\nexport const useSkyMat = (radius: number, colors: number[]): ShaderMaterial => {\n  const mat = useMemo(\n    () =>\n      new ShaderMaterial({\n        uniforms: {\n          radius: new Uniform(radius),\n          colors: new Uniform(colors),\n          num_colors: new Uniform(colors.length),\n          time: new Uniform(0),\n        },\n        vertexShader: vert,\n        fragmentShader: frag,\n        side: DoubleSide,\n      }),\n    [radius, colors]\n  );\n\n  const limiter = useLimiter(30);\n  useFrame(({ clock }) => {\n    if (!mat || !limiter.isReady(clock)) return;\n\n    // @ts-ignore\n    mat.uniforms.time.value = ((new Date() / 1000) % 10000) / 5;\n  });\n\n  return mat;\n};\n\nconst vert = `\n    varying vec3 absPosition;\n    void main() {\n        absPosition = position;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n    }\n`;\n\nconst frag = `\n  uniform highp float radius;\n  uniform highp float time;\n  uniform int num_colors;\n  uniform highp float colors[100];\n  varying vec3 absPosition;\n  \n  //\n  // Description : Array and textureless GLSL 2D/3D/4D simplex\n  //               noise functions.\n  //      Author : Ian McEwan, Ashima Arts.\n  //  Maintainer : ijm\n  //     Lastmod : 20110822 (ijm)\n  //     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n  //               Distributed under the MIT License. See LICENSE file.\n  //               https://github.com/ashima/webgl-noise\n  //\n  \n  vec3 mod289(vec3 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n  }\n  \n  vec4 mod289(vec4 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n  }\n  \n  vec4 permute(vec4 x) {\n       return mod289(((x*34.0)+1.0)*x);\n  }\n  \n  vec4 taylorInvSqrt(vec4 r)\n  {\n    return 1.79284291400159 - 0.85373472095314 * r;\n  }\n  \n  float snoise(vec3 v)\n    {\n    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n  \n  // First corner\n    vec3 i  = floor(v + dot(v, C.yyy) );\n    vec3 x0 =   v - i + dot(i, C.xxx) ;\n  \n  // Other corners\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min( g.xyz, l.zxy );\n    vec3 i2 = max( g.xyz, l.zxy );\n  \n    //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n    //   x1 = x0 - i1  + 1.0 * C.xxx;\n    //   x2 = x0 - i2  + 2.0 * C.xxx;\n    //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n    vec3 x1 = x0 - i1 + C.xxx;\n    vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n    vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n  \n  // Permutations\n    i = mod289(i);\n    vec4 p = permute( permute( permute(\n               i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n             + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n             + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n  \n  // Gradients: 7x7 points over a square, mapped onto an octahedron.\n  // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n    float n_ = 0.142857142857; // 1.0/7.0\n    vec3  ns = n_ * D.wyz - D.xzx;\n  \n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n  \n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n  \n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n  \n    vec4 b0 = vec4( x.xy, y.xy );\n    vec4 b1 = vec4( x.zw, y.zw );\n  \n    //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n    //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n  \n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n  \n    vec3 p0 = vec3(a0.xy,h.x);\n    vec3 p1 = vec3(a0.zw,h.y);\n    vec3 p2 = vec3(a1.xy,h.z);\n    vec3 p3 = vec3(a1.zw,h.w);\n  \n  //Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n  \n  // Mix final noise value\n    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                  dot(p2,x2), dot(p3,x3) ) );\n    } \n  \n  float get_mix(int index, float noise) { \n    highp float lastPerc = float(index*3 - 1) / float(num_colors);\n    highp float thisPerc = float(index*3) / float(num_colors);\n    highp float height = ((absPosition.y + radius) / 2.) / (radius);\n    return smoothstep(lastPerc, thisPerc, height + noise * 0.1);\n  }\n\n  void main() {\n    highp float yCoord = (gl_FragCoord.y / gl_FragCoord.w);\n    highp float height = ((absPosition.y + radius) / 2.) / (radius);\n    \n    highp float noise_smooth = snoise((absPosition * 0.01)+ time*0.1);\n    highp float noise_rough = snoise((absPosition * 0.1)+ time*0.45);\n    \n\n    // color 0\n    vec3 color = vec3(colors[0], colors[1], colors[2]);\n    \n    // color 1\n    highp float noise1 = noise_smooth * 2. + noise_rough * 0.2;\n    color = mix(color, vec3(colors[3], colors[4], colors[5]), get_mix(1, noise1));\n\n    // color 2\n    highp float noise2 = noise_smooth * 4. + noise_rough * 0.2;\n    color = mix(color, vec3(colors[6], colors[7], colors[8]), get_mix(2, noise2));\n\n    // color 3\n    highp float noise3 = noise_smooth * 1.5 + noise_rough * 0.8;\n    color = mix(color, vec3(colors[9], colors[10], colors[11]), get_mix(3, noise3));\n\n    gl_FragColor = vec4( color, 1.0 );\n  }\n`;\n"]},"metadata":{},"sourceType":"module"}