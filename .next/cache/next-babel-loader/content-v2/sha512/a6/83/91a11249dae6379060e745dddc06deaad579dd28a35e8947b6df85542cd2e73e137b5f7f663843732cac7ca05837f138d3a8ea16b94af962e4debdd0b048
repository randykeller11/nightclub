{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// @ts-ignore\nimport * as culori from \"culori\";\n\n/**\n * an idea is the fundamental atom of the ideal reality.\n * everything is an idea, whether the idea is accurately visualized or not.\n */\nexport class Idea {\n  // definition\n  // aliases\n  // size\n  // thought\n  // mediation\n  // [0, 1)\n  // [0, 1]\n  // [0, 1]\n  constructor() {\n    _defineProperty(this, \"id\", void 0);\n\n    _defineProperty(this, \"props\", void 0);\n\n    _defineProperty(this, \"name\", void 0);\n\n    _defineProperty(this, \"schema\", void 0);\n\n    _defineProperty(this, \"npm_dependencies\", void 0);\n\n    _defineProperty(this, \"purpose\", void 0);\n\n    _defineProperty(this, \"predecessor\", void 0);\n\n    _defineProperty(this, \"mediation\", void 0);\n\n    _defineProperty(this, \"specificity\", void 0);\n\n    _defineProperty(this, \"utility\", void 0);\n\n    this.setFromCreation();\n    return this;\n  }\n\n  setFromCreation(m = 0, s = 0, u = 0.5) {\n    this.mediation = m;\n    this.specificity = s;\n    this.utility = u;\n    return this;\n  }\n\n  updateFromText(text) {\n    const len = text.length;\n    this.mediation = hashStringToRange(text);\n    this.specificity = (1 - (len == 0 ? 1 : 1 / len)) * 0.5;\n    return this;\n  }\n\n  updateUtility(utility) {\n    this.utility = utility;\n    return this;\n  }\n\n  getHex() {\n    const fixedColor = culori.rgb({\n      mode: \"oklch\",\n      l: this.utility,\n      c: this.specificity * 0.322,\n      h: this.mediation * 360\n    });\n    return culori.formatHex(fixedColor);\n  }\n\n  getOpposite() {\n    const newM = this.mediation + 0.5 > 1 ? this.mediation - 0.5 : this.mediation + 0.5;\n    const newS = this.specificity;\n    const newU = 0.5 - (this.utility - 0.5);\n    return new Idea().setFromCreation(newM, newS, newU);\n  }\n\n}\nconst AVG_CHAR_VAL = 100; // each char is roughly 100, so loop every ~50 chars\n\nconst hashStringToRange = (str, loop = 20) => {\n  let count = 0;\n\n  for (let i = 0; i < str.length; i++) {\n    count += str.substr(i, 1).charCodeAt(0);\n  }\n\n  const scaledLoop = loop * AVG_CHAR_VAL;\n  return count % scaledLoop / scaledLoop;\n};\n\nconst wrapNumber = (num, range = 10) => {\n  return num % range / range;\n};","map":{"version":3,"sources":["/Users/dub_ceo/Desktop/spacesvr-starter/src/ideas/Builder12/layers/basis/classes/idea.ts"],"names":["culori","Idea","constructor","setFromCreation","m","s","u","mediation","specificity","utility","updateFromText","text","len","length","hashStringToRange","updateUtility","getHex","fixedColor","rgb","mode","l","c","h","formatHex","getOpposite","newM","newS","newU","AVG_CHAR_VAL","str","loop","count","i","substr","charCodeAt","scaledLoop","wrapNumber","num","range"],"mappings":";;AAAA;AACA,OAAO,KAAKA,MAAZ,MAAwB,QAAxB;;AAGA;AACA;AACA;AACA;AACA,OAAO,MAAMC,IAAN,CAAW;AAChB;AAIA;AAGA;AAIA;AAIA;AACmB;AACE;AACJ;AAEjBC,EAAAA,WAAW,GAAG;AAAA;;AAAA;;AAAA;;AAAA;;AAAA;;AAAA;;AAAA;;AAAA;;AAAA;;AAAA;;AACZ,SAAKC,eAAL;AACA,WAAO,IAAP;AACD;;AAEDA,EAAAA,eAAe,CAACC,CAAC,GAAG,CAAL,EAAQC,CAAC,GAAG,CAAZ,EAAeC,CAAC,GAAG,GAAnB,EAAwB;AACrC,SAAKC,SAAL,GAAiBH,CAAjB;AACA,SAAKI,WAAL,GAAmBH,CAAnB;AACA,SAAKI,OAAL,GAAeH,CAAf;AAEA,WAAO,IAAP;AACD;;AAEDI,EAAAA,cAAc,CAACC,IAAD,EAAe;AAC3B,UAAMC,GAAG,GAAGD,IAAI,CAACE,MAAjB;AACA,SAAKN,SAAL,GAAiBO,iBAAiB,CAACH,IAAD,CAAlC;AACA,SAAKH,WAAL,GAAmB,CAAC,KAAKI,GAAG,IAAI,CAAP,GAAW,CAAX,GAAe,IAAIA,GAAxB,CAAD,IAAiC,GAApD;AAEA,WAAO,IAAP;AACD;;AAEDG,EAAAA,aAAa,CAACN,OAAD,EAAkB;AAC7B,SAAKA,OAAL,GAAeA,OAAf;AAEA,WAAO,IAAP;AACD;;AAEDO,EAAAA,MAAM,GAAW;AACf,UAAMC,UAAU,GAAGjB,MAAM,CAACkB,GAAP,CAAW;AAC5BC,MAAAA,IAAI,EAAE,OADsB;AAE5BC,MAAAA,CAAC,EAAE,KAAKX,OAFoB;AAG5BY,MAAAA,CAAC,EAAE,KAAKb,WAAL,GAAmB,KAHM;AAI5Bc,MAAAA,CAAC,EAAE,KAAKf,SAAL,GAAiB;AAJQ,KAAX,CAAnB;AAOA,WAAOP,MAAM,CAACuB,SAAP,CAAiBN,UAAjB,CAAP;AACD;;AAEDO,EAAAA,WAAW,GAAS;AAClB,UAAMC,IAAI,GACR,KAAKlB,SAAL,GAAiB,GAAjB,GAAuB,CAAvB,GAA2B,KAAKA,SAAL,GAAiB,GAA5C,GAAkD,KAAKA,SAAL,GAAiB,GADrE;AAEA,UAAMmB,IAAI,GAAG,KAAKlB,WAAlB;AAEA,UAAMmB,IAAI,GAAG,OAAO,KAAKlB,OAAL,GAAe,GAAtB,CAAb;AACA,WAAO,IAAIR,IAAJ,GAAWE,eAAX,CAA2BsB,IAA3B,EAAiCC,IAAjC,EAAuCC,IAAvC,CAAP;AACD;;AAlEe;AAqElB,MAAMC,YAAY,GAAG,GAArB,C,CAA0B;;AAE1B,MAAMd,iBAAiB,GAAG,CAACe,GAAD,EAAcC,IAAI,GAAG,EAArB,KAAoC;AAC5D,MAAIC,KAAK,GAAG,CAAZ;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,GAAG,CAAChB,MAAxB,EAAgCmB,CAAC,EAAjC,EAAqC;AACnCD,IAAAA,KAAK,IAAIF,GAAG,CAACI,MAAJ,CAAWD,CAAX,EAAc,CAAd,EAAiBE,UAAjB,CAA4B,CAA5B,CAAT;AACD;;AACD,QAAMC,UAAU,GAAGL,IAAI,GAAGF,YAA1B;AACA,SAAQG,KAAK,GAAGI,UAAT,GAAuBA,UAA9B;AACD,CAPD;;AASA,MAAMC,UAAU,GAAG,CAACC,GAAD,EAAcC,KAAK,GAAG,EAAtB,KAA6B;AAC9C,SAAQD,GAAG,GAAGC,KAAP,GAAgBA,KAAvB;AACD,CAFD","sourcesContent":["// @ts-ignore\nimport * as culori from \"culori\";\nimport { NpmDependencies, Schema } from \"../types/idea\";\n\n/**\n * an idea is the fundamental atom of the ideal reality.\n * everything is an idea, whether the idea is accurately visualized or not.\n */\nexport class Idea {\n  // definition\n  id: string;\n  props: any;\n\n  // aliases\n  name: string;\n\n  // size\n  schema: Schema;\n  npm_dependencies: NpmDependencies;\n\n  // thought\n  purpose: string;\n  predecessor: string;\n\n  // mediation\n  mediation: number; // [0, 1)\n  specificity: number; // [0, 1]\n  utility: number; // [0, 1]\n\n  constructor() {\n    this.setFromCreation();\n    return this;\n  }\n\n  setFromCreation(m = 0, s = 0, u = 0.5) {\n    this.mediation = m;\n    this.specificity = s;\n    this.utility = u;\n\n    return this;\n  }\n\n  updateFromText(text: string) {\n    const len = text.length;\n    this.mediation = hashStringToRange(text);\n    this.specificity = (1 - (len == 0 ? 1 : 1 / len)) * 0.5;\n\n    return this;\n  }\n\n  updateUtility(utility: number) {\n    this.utility = utility;\n\n    return this;\n  }\n\n  getHex(): string {\n    const fixedColor = culori.rgb({\n      mode: \"oklch\",\n      l: this.utility,\n      c: this.specificity * 0.322,\n      h: this.mediation * 360,\n    });\n\n    return culori.formatHex(fixedColor);\n  }\n\n  getOpposite(): Idea {\n    const newM =\n      this.mediation + 0.5 > 1 ? this.mediation - 0.5 : this.mediation + 0.5;\n    const newS = this.specificity;\n\n    const newU = 0.5 - (this.utility - 0.5);\n    return new Idea().setFromCreation(newM, newS, newU);\n  }\n}\n\nconst AVG_CHAR_VAL = 100; // each char is roughly 100, so loop every ~50 chars\n\nconst hashStringToRange = (str: string, loop = 20): number => {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    count += str.substr(i, 1).charCodeAt(0);\n  }\n  const scaledLoop = loop * AVG_CHAR_VAL;\n  return (count % scaledLoop) / scaledLoop;\n};\n\nconst wrapNumber = (num: number, range = 10) => {\n  return (num % range) / range;\n};\n"]},"metadata":{},"sourceType":"module"}